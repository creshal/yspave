#! /usr/bin/env python
# (c) Samuel Vincent Creshal <samuel@creshal.de> 2014
import argparse,getpass,sys, readline,os, csv
from yspave import pave, crypto, util, pwgen
from colorama import Fore as fg

actions = '''scrypt based password manager.

Actions:
	new	Prompts for title/description and generates a new password
		with supplied entropy (default: %i bit)
	add	Prompts for title, description and password
	edit	Edits entry with supplied query ID
	del	Deletes entry with supplied query ID
	get	Searches the DB for the supplied query string
	pwgen	Generate a random password with supplied entropy and print it
		(default: %i bit)
	import	Imports passwords from a CSV file.
		Column order is title, description, password
		The format is the default Excel/Calc format (comma separation,
		quoting optional).
	migrate	Re-syncs the database, migrating it to new database formats
		and doing other maintenance if necessary.
		This is also done automatically on all writing operations (edit/add/del).

Password generator options:
	x, xkcd		Random word generator as per XKCD 936
	a, alnum	Random letters/numbers
	p, print	Random characters (letters, digits, punctuation)

'''%(pave.PaveCfg.pwgen_bits,pave.PaveCfg.pwgen_bits)
examples = '''Examples:
	yspavectl pwgen 192
		Generates a random alphanumeric password and prints it

	yspavectl -m x pwgen
		Generates a random "sentence"

	yspavectl get foobar
		Shows all passwords matching "foobar" in their
		description or title

	yspavectl new
		Generates a new password and saves it together with
		supplied metadata

	yspavectl edit 3
		Edit the password with ID #3
'''

parser = argparse.ArgumentParser(prog=pave.appname,description=actions,formatter_class=argparse.RawTextHelpFormatter,epilog=examples)
parser.add_argument('--version', '-v', action='version', version='%(prog)s '+pave.appvers)
parser.add_argument('--file','-f', help='Database file',nargs='?',default=pave.db_filename)
parser.add_argument('--config-file','-c',help='Configuration file',nargs='?',default=pave.config_filename)
parser.add_argument('--pwgen-mode','-m',choices=['print','p','alnum','a','xkcd','x'],default='a',nargs='?')
parser.add_argument('action', choices=['migrate','new','add','edit','del','get','pwgen','import'], default='get',nargs='?')
parser.add_argument('query',default=None,nargs='?',help='ID for edit/del mode, search string for get mode')
args = parser.parse_args()

if os.path.exists (args.config_file):
	config = pave.PaveCfg (args.config_file, args.pwgen_mode)
else:
	if args.config_file == pave.config_filename:
		config = pave.PaveCfg (None, args.pwgen_mode)
	else: raise IOError ('Config file %s does not exist!'%args.config_file)
gen = pwgen.PwGen (config)

if args.action == 'pwgen':
	print (gen.mkpass (args.query))
	sys.exit (0)

password = getpass.getpass ('Database password: ')
db = crypto.PaveDB (password, args.file, config)
del (password)

if args.action in ['new','add']:
	title, desc = util.prompt ('Title: '), util.prompt ('Description: ')
	pw = gen.mkpass (args.query) if args.action == 'new' else getpass.getpass()
	db.additem (title, pw, desc)
	if args.action=='new': print ('Generated password: '+fg.YELLOW+pw+fg.RESET)
	db.syncdb()


if args.action == 'edit':
	print ('Leave fields blank if you do not want to change them.')

	entry = db.getitem (args.query)
	nt = util.prompt ('Title: %s\nNew: '%entry['Title'])
	if not nt: nt=entry['Title']
	nd = util.prompt ('Description: %s\nNew: '%entry['Details'])
	if not nd: nd=entry['Details']

	pwchoice = util.prompt ('Change password? [(y)es/(N)o/(g)enerate]').lower()
	if pwchoice == 'y':
		print ('Password: %s'%db.dec (entry['Password'],db.key))
		np = getpass.getpass ('New: ')
	elif pwchoice == 'g':
		np = gen.mkpass (args.query)
		print ('Generated password: '+fg.YELLOW+pw+fg.RESET)
	else:
		np = db.dec (entry['Password'],db.key)

	db.edititem (args.query, nt, np, nd)
	db.syncdb()


if args.action == 'del':
	db.delitem (args.query)
	db.syncdb()


if args.action == 'migrate':
	db.syncdb()


if args.action == 'get':
	headings = []
	headings.append (['ID','Title','Password','Details'])
	items = sorted (db.finditems (args.query, True), key=lambda x:x[0])
	headings.extend (items)
	util.print_table (headings, True)

if args.action == 'import':
	with open (args.query, newline='') as f:
		r = csv.DictReader (f, fieldnames=('title','details','password'))
		for line in r:
			db.additem (**line)
	db.syncdb()

